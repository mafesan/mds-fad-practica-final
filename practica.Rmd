---
title: "Práctica Métodos de Análisis de datos"
author: "Edgli Morales, David Ruiz y Miguel Ángel Fernández - Máster en Data Science, URJC"
date: "Diciembre de 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r init, include=FALSE}
# Cargamos los paquetes que vamos a usar en el informe
library(dplyr)
library(tidyr)
library(ggplot2)
library(egg)
library(GGally)

library(ISLR)
library(car)
library(DMwR2)
library(faraway)
library(mlbench)

library(knitr)
library(kableExtra)
library(htmltools)
library(bsplus)
library(RColorBrewer)

library(VIM)
library(mice)
library(R.methodsS3)
library(R.oo)
library(R.utils)

library(Hmisc)
library(ggthemes)
library(leaps)
library(dummies)

# Koki
library(data.table)
library(corrplot)
library(GGally)
library(tidyverse)
library(PerformanceAnalytics)
library(plotly)

# Seed
set.seed(3)

# Gráficos
library(RColorBrewer)
library(gridExtra)
```

# Introducción

El conjunto de datos que se analiza en esta práctica trata sobre información acerca de aplicaciones móviles disponibles en el *App Store*, la tienda de aplicaciones de *Apple*.

En esta practica se pretende analizar sus variables con el fin de plantear objetivos que aporten valor, utilizando las técnicas principales para el análisis y modelado de datos

# Análisis exploratorio inicial - EDA

```{r read_file}
data_apps = read.csv('AppleStore.csv')
```

Cargamos el conjunto datos y mostramos una vista preliminar de los tipos de variables que contiene:

```{r}
str(data_apps)
```

Observamos que el data set consta de 7197 observaciones, 17 variables, de las cuales aproximadamente 8 son números enteros, 5 categóricas y 4 representan valores numéricos.

Con la función head visualizamos el nombre de las observaciones y los valores que contiene cada una:

```{r}
head(data_apps)
```

## Tipo de Variables

| VARIABLE                                                         	| DESCRIPCIÓN                                                               	| TIPO DE VARIABLE      	|
|------------------------------------------------------------------	|---------------------------------------------------------------------------	|-----------------------	|
| X: Index                                                         	| Indice                                                                    	| Cuantitativa Discreta  	|
| id: Apple ID                                                     	| Numero de identificación de la app                                        	| Categórica            	|
| track_name: App Name                                             	| Nombre de la aplicación                                                   	| Categórica            	|
| size_bytes: Size (in Bytes)                                      	| Peso de la aplicación en bytes                                            	| Cuantitativa Continua 	|
| currency: Currency Type<br>                                      	| Tipo de Moneda                                                            	| Categórica            	|
| pric: Price amount                                               	| Precio                                                                    	| Cuantitativa Continua 	|
| rating_count_tot: User Rating counts (for all version)           	| Cantidad de Reseñas                                                       	| Cuantitativa Continua 	|
| rating_count_ver: User Rating counts (for current version)       	| Cantidad de Reseñas para la version actual                                	| Cuantitativa Continua 	|
| user_rating: Average User Rating value (for all version)         	| Valor promedio de las Reseñas Totales                                     	| Cuantitativa Discreta 	|
| user_rating_ver: Average User Rating value (for current version) 	| Valor promedio de las Reseñas para la versión actual                      	| Cuantitativa Discreta 	|
| ver : Latest version code                                        	| Versión actual                                                            	| Categórica            	|
| cont_rating: Content Rating                                      	| Calificación del contenido (Edad)                                         	| Categórica            	|
| prime_genre: Primary Genre                                       	| Genero de la aplicación                                                   	| Categórica            	|
| sup_devices.num: Number of supporting devices                    	| Número de dispositivos soportados                                         	| Cuantitativa Continua 	|
| ipadSc_urls.num": Number of screenshots showed for display       	| Número de capturas de pantalla mostrados antes del acceso a la aplicación 	| Cuantitativa Continua 	|
| lang.num: Number of supported languages                          	| Lenguajes Soportados                                                      	| Cuantitativa Continua 	|
| vpp_lic: Vpp Device Based Licensing Enabled* VPP                 	| Licencia - Compras por Volumen de Apple                                   	| Categórica Binaria    	|


## Correlación
```{r, warning= FALSE, fig.align='center', fig.show='hold', echo=FALSE, message=FALSE}
ggcorr(data_apps, low='steelblue', mid='white', high ='lightcoral')
```

Al observar la matriz de correlación apreciamos que la mayoría de las variables no se relacionan linealmente a un nivel significativo, sin resaltaremos las que guardan cierta correlación positiva:

* size_bytes vs sup_devices num: Puede deberse que al ser una aplicación que pueda ser ejecutada para varias versiones su peso ascienda considerablemente.

* size_bytes vs ipadSc_urls.num: El peso se aplicación puede influir en el numero screen shot que presenta la aplicación.

* lang.num vs user_rating_ver: La cantidad de lenguaje soportado influye sobre los rating de las ultimas versiones.

* lang.num vs user_rating: La cantidad de lenguaje soportado influye sobre los rating.

* lang.num vs rating_count_tot: El lenguaje se relaciona con el numero de calificaciones total que recibe.

* ipadSc_urls.num vs user_rating_ver: El número de capturas de pantalla o *screenshots* con el user_rating_ver.

# Detección, tratamiento e imputación de datos faltantes

Al realizar un análisis preliminar de los datos, observamos que no hay valores faltantes.
```{r comprobar_na}
sum(is.na(data_apps))
```

Antes de empezar a trabajar con los datos en más profundidad, vamos a simular estos datos faltantes. Primero, vamos a generar un gran porcentaje de valores faltantes en una de las variables, "`currency`", que indica la divisa del precio de la aplicación. El porcentaje de valores faltantes será en este caso de un 80\%.

```{r generate_missing_currency}
num_filas <- nrow(data_apps)
porcentaje_missing <- 80
num_missing <- round((num_filas * porcentaje_missing)/100)
pos_missing <- sort(sample(1:num_filas, num_missing, replace=FALSE))

data_apps$currency[c(pos_missing)] <- NA
```

Aunque en los datos originales todos los valores de esta columna son `USD` (dólares estadounidenses), simulamos que nos faltan tantos valores de esta variable que la hace prácticamente inusable en cuanto a la información que nos proporciona.

En una situación en la que tenemos datos del precio pero no sabemos la divisa en la que está ese valor, hemos decidido crear una variable categorizando las aplicaciones como gratuitas o de pago.

A continuación, generamos valores faltantes en las variables `user_rating` y `user_rating_ver`, que describen la valoración media de los usuarios en estrellas (valor de 0 a 5) para todas las versiones de la aplicación y sólo para la última versión, respectivamente.

En este caso, generamos un 12\% de valores faltantes para `user_rating` y un 8% para `user_rating_ver`.

```{r generate_missing_user_rating}
num_filas <- nrow(data_apps)
porcentaje_missing <- 12
num_missing <- round((num_filas * porcentaje_missing)/100)

pos_missing <- sort(sample(1:num_filas, num_missing, replace=FALSE))
data_apps$user_rating[c(pos_missing)] <- NA

porcentaje_missing <- 8
num_missing <- round((num_filas * porcentaje_missing)/100)

pos_missing <- sort(sample(1:num_filas, num_missing, replace=FALSE))
data_apps$user_rating_ver[c(pos_missing)] <- NA
```

Una vez que hemos generado los valores faltantes, vamos a representar estos valores en un histograma y cómo se distribuyen en el conjunto.

```{r repr_valores_missing, echo=FALSE, message=TRUE, warning=FALSE}
aggr_plot <- aggr(data_apps, col=c('steelblue','coral'), numbers=TRUE, sortVars=TRUE,
                  labels=names(data_apps), cex.axis=.7, gap=3,
                  ylab=c("Histograma de datos faltantes","Patrón"))
```

En el histograma (gráfico de la izquierda), observamos que la proporción de valores faltantes coincide con los valores que hemos generado. En el gráfico de la derecha podemos ver cuál es la propoción de que falten valores siguiendo una combinación de variables. Por ejemplo, en la primera fila está el porcentaje de filas que contienen faltantes en las variables `user_rating` y `user_rating_ver` a la vez.

A continuación, vemos un gráfico que representa cómo están distribuídos los valores faltantes de estas dos variables y cuál es el rango de sus valores, incluyendo su media y su mediana:

```{r repr_variables_missing}
data_apps %>% select(user_rating, user_rating_ver) %>% marginplot()
```

## Imputación de valores faltantes

Antes de realizar la imputación, vamos a proceder a eliminar columnas que no ofrecen ninguna información para la imputación de estas variables y la razón por la que se elimina:

* `track_name`: El nombre de la aplicación en el *App Store*.
* `currency`: divisa, decidimos eliminar esta variable por tener un porcentaje tan alto de valores faltantes.
* `ver`: Versión de la aplicación. Como no tiene porqué seguir un estándar, carece de significado.

```{r eliminar_columnas}
data_apps_clean <- data_apps %>%
  select(-c(track_name, currency, ver))
```

### Imputación usando el paquete MICE

Para realizar la imputación de valores faltantes de las variables `user_rating` y `user_rating_ver` hemos usado el paquete MICE, que incluye múltiples métodos para imputar estos valores. Nosotros hemos aplicado el método `cart`. Este método se basa en árboles de clasificación y regresión. Los modelos CART (*Classification and regression trees*) buscan predictores y puntos en estos predictores donde dividir la muestra. Estos puntos dividen la muestra en más sub-muestras homogéneas, y este proceso se repite en las sub-muestras hasta que una serie de divisiones define un árbol binario. Si la variable objetivo es discreta, será un árbol de clasificación mientras que si es continua será un árbol de regresión.

El parámetro `m` indica el número de imputaciones que se van a realizar para poder elegir cuál es la que finalmente se aplica. En este caso, `m` vale 1 ya que sólo queremos que la imputación se realice una vez.

```{r imputacion_datos}
apps_imp = mice(data_apps_clean, method = "cart", m = 1)
```

```{r}
data_apps_imp <- complete(apps_imp)
```

# Generar conjuntos de entrenamiento, test y validación

Separamos el número de observaciones en dos bloques: el de Training (un 75\%) y el de Test (un 25\%). Además, 
para realizar una simulación de lo que ocurrirá al probar los datos de Test, dividimos el conjunto de Training para obtener también un conjunto de validación, por lo que la proporción queda de la siguiente manera respecto del número total de observaciones:

* Training: 50\%
* Validación: 25\%
* Test: 25\%

```{r separar_training_test}

# Separamos los datos en los siguientes porcentajes: Train (50), Test (25), Validación (25)

# Obtenemos la muestra del 50% y filtramos por esos elementos
train = sample(1:nrow(data_apps_imp), .5 * nrow(data_apps_imp), replace = FALSE)
data_train = data_apps_imp[train,]

# Cogemos el 50% restante y lo dividimos en dos partes iguales para Test y para Validación
test_validacion = data_apps_imp[-train,]
test = sample(1:nrow(test_validacion), .5 * nrow(test_validacion), replace = FALSE)

# Filtramos para obtener los otros dos conjuntos
data_test = test_validacion[test,]
data_validacion = test_validacion[-test,]
```

# Definición de objetivos

Al observar las variables con las que cuenta el dataset, nos resulta interesante la variable `rating_count_tot` la cual contabiliza el numero de calificaciones y/o reseñas que ha recibido la aplicación. Aunque no tenemos el dato del número de descargas, la variable `rating_count_tot` seguramente tendrá una correlación fuerte con el dato del número de descargas (dato que no facilita Apple de manera pública). Podemos asumir que el número de calificaciones que ha recibido la aplicación corresponde a un número de usuarios que ha descargado la aplicación y que además es un usuario activo de dicha aplicación, por lo que esta variable nos resulta interesante como una aproximación de su número de descargas.

Dicho esto, el objetivo general que nos gustaría alcanzar analizando este conjunto de datos es obtener un modelo que prediga cuántas valoraciones va a obtener una aplicación en función de una serie de variables. Además, buscamos encontrar qué variables son relevantes a la hora de obtener más o menos reseñas.

Además de este objetivo principal, surgen unos cuantos objetivos secundarios como relaciones entre variables que pueden ser interesantes. Por ejemplo: 

* ¿Está relacionado el número de idiomas a los que la aplicación está traducida con su valoración y el número de valoraciones?
* ¿Influye el número de capturas de pantalla que se adjuntan en la pantalla de descarga?
* ¿A qué género pertenecen las aplicaciones más y menos valoradas?

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}

top_10 <- data_apps %>% top_n(10,rating_count_tot)

orden = top_10$rating_count_tot %>% order(decreasing = T)
orden
top_10$track_name = factor(top_10$track_name, levels = top_10$track_name[orden])

ggplot(top_10, aes(x=top_10$track_name , y=top_10$rating_count_tot))+
  geom_bar(stat = 'identity', color = 'steelblue', fill='steelblue')+
  labs(x = "Nombre de la APP", y = "Num Total de Calificaciones", title = "APP VS")+
  theme(plot.title = element_text(hjust = 0.5, face="bold", size =10), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(face = "bold", size = 12, angle = 45, hjust = 1), axis.text.y = element_text(face = "bold", size = 12))

```

El top-10 de variables con el mayor numero de calificaciones corroboramos que el numero de usuarios que califican la aplicación se corresponde a las variables con mas "éxito" en la actualidad.

```{r summary}
summary(data_train)

hist(data_train$user_rating)
```

```{r initial_plots, warning=FALSE}
stats_apps_cor <-
  data_train %>%
  select(price:user_rating_ver, ipadSc_urls.num,
         sup_devices.num, lang.num, size_bytes)
ggpairs(stats_apps_cor)
```

# Transformación de variables cuantitativas

Procederemos a analizar las variables cuantitativas del data set, de esta manera estudiaremos su comportamiento con el fin de relacionar patrones y poder ajustar su escala (en caso de que sea necesario) con el fin de visualizar mejor su distribución.


## Variable rating_count_tot

El *rating_count_tot* que representa el total de calificaciones o reseñas otorgadas a la aplicación de distribuye de la siguiente manera.


```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data=data_train, aes(x=rating_count_tot))+
  geom_histogram(bins=100, color='steelblue', fill='steelblue')+
  labs(x = "Numero de Calificaciones total", y ="Frecuencia" , title = "HISTOGRAMA NÚMERO DE CALIFICACIONES TOTALES")+
  theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```


Para poder apreciar su distribución aplicaremos un logaritmo que nos permita apreciar mayormente su distribución.

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data=data_train, aes(x=log10(rating_count_tot)))+
  geom_histogram(bins=10, color='steelblue', fill='steelblue')+
  labs(x = "Numero de Calificaciones total", y ="Frecuencia" , title = "HISTOGRAMA NÚMERO DE CALIFICACIONES TOTALES", subtitle = "Log")+theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```


**Notamos que se nos eliminan 929 datos, que pertenecen a los valores 0 de la variable**

Aplicamos log10 +1 para apreciar los valores correspondiente a 0 que se nos han eliminado con el log anterior.


```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data=data_train, aes(x=log10(1+(rating_count_tot))))+
  geom_histogram(bins=10, color='steelblue', fill='steelblue')+
  labs(x = "Numero de Calificaciones total", y ="Frecuencia" , title = "HISTOGRAMA NÚMERO DE CALIFICACIONES TOTALES", subtitle = "Log +1")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```


Analizamos la variable a través de un box plot para confirmar su distribución

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data=data_train, aes(x= " ", y= log10(1+(rating_count_tot))))+
  geom_boxplot(color='black', fill='steelblue')+
  labs(x = "" , y ="Numero de calificaciones totales" , title = "BOX PLOT NÚMERO DE CALIFICACIONES TOTALES", subtitle = "Log +1")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```


Analizamos los cuantiles de los datos.

```{r}
quantile(data_train$rating_count_tot, probs = seq(0,1,0.05))
```


Podemos notar que el comportamiento de *rating_count_tot* varia drásticamente, el salto entre el cuantil 95% al 100% varia desde 48107 a 2974676.

Solo el 0.13% de los datos representan valores mayores de mas del millón.


```{r}
top_10 <- data_train %>% top_n(10, rating_count_tot)
(nrow(top_10)/nrow(data_train))*100
```

Añadimos la variable transformada al data_train

```{r}
data_train <- data_train %>% 
  mutate(rating_count_tot_new = log10(1+rating_count_tot))
```


## Variable Size_bytes

La principal problemática que nos genera esta variable es la comprensión de los datos. Para hacerlos comprensibles para todas las personas, a través de la función “Hsize” se transforma  la medida de bytes a  Mb para que sea más legible.

```{r include=FALSE}
Mb <- data.frame(data_train$X, data_train$size_bytes)
names(Mb)[names(Mb) == "data_train.X"] <- "X"
names(Mb)[names(Mb) == "data_train.size_bytes"] <- "size_bytes"

# Transformamos la variable de bytes a Mb

size <- hsize(Mb$size_bytes, standard="SI")
Mb$size_MB <- as.numeric(str_replace(size, " MB", ""))

Mb <- select(Mb, X, size_MB)
head(Mb)
# Unimos la nueva columna al Dataframe original
data_train <- merge (x=data_train, y=Mb, by="X")
```

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data_train, aes(x=size_bytes)) +
  geom_histogram(bins=10, fill='steelblue')+
  labs(x = "Peso de la Aplicación" , y ="Frecuencia" , title = "HISTOGRAMA PESO DE LA APLICACIÓN", subtitle = "Bytes")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```

Observamos que la mayoría se encuentra ubicada hacia el cero, por ende aplicaremos un logaritmo y así poder apreciar su distribución

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data_train, aes(x=log10(size_bytes))) +
  geom_histogram(bins=10, fill='steelblue')+
  labs(x = "Peso de la Aplicación" , y ="Frecuencia" , title = "HISTOGRAMA PESO DE LA APLICACIÓN", subtitle = "Log10")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```

Añadimos la variable transformada al data_train

```{r}
data_train <- data_train %>% 
  mutate(size_bytes_new = log10(size_bytes))
```

## Variable sup_devices.num

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data_train, aes(x=sup_devices.num))+
  geom_histogram(bins=10, fill='steelblue')+
  labs(x = "dispositivos Soportados" , y ="Frecuencia" , title = "HISTOGRAMA DISPOSITIVOS SOPORTADOS")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```

Al aplicar potencia cuadrada a esta variable observamos un poco mejor aquellos valores cercanos al cero, sin embargo aún asi al prevalecer los valores entre el 35-40 es inevitable esta distribución

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data_train, aes(x=(sup_devices.num)**2))+
  geom_histogram(bins=30, fill='steelblue')+
  labs(x = "Dispositivos Soportados" , y ="Frecuencia" , title = "HISTOGRAMA PESO DE LA APLICACIÓN", subtitle = "x^2")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```

Transformamos la variable elevando al cuadrado para visualizar mejor sus valores hacia la izquierda.


Añadimos la variable transformada al data_train

```{r}
data_train <- data_train %>% 
  mutate(sup_devices_new = (sup_devices.num)**2)
```

## Variable lang.num

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data_train, aes(x=(lang.num))) +
  geom_histogram(bins=10, fill='steelblue')+
  labs(x = "Nº de Idiomas" , y ="Frecuencia" , title = "HISTOGRAMA Nº IDIOMAS")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```



```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(data_train, aes(x=log10(1+(lang.num)))) +
  geom_histogram(bins=10, fill='steelblue')+
  labs(x = "Nº de Idiomas" , y ="Frecuencia" , title = "HISTOGRAMA Nº IDIOMAS", subtitle = "log10+1")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, angle = 45, hjust = 1), axis.text.y = element_text(size = 10))
```

Añadimos la variable transformada al data_train

```{r}
data_train <- data_train %>% 
  mutate(lang.num_new = log10(1+(lang.num)))
         
```

# Procesado de variables cualitativas

## Rating de edad

Existe una clasificación de contenido para las aplicaciones, los estándares más importantes son: A nivel europeo “PEGI” y a nivel americano “ESRB”. Las principales distribuidoras de aplicaciones para móviles, cómo son Apple Store o Google Play, siguen una clasificación diferente.

```{r include=FALSE}
# Nos quedamos con la variable objetivo y un identificador para integrarlo con la origen tras procesar la variable
Rating <- data.frame(data_train$X, data_train$cont_rating)

names(Rating)[names(Rating) == "data_train.X"] <- "X"
names(Rating)[names(Rating) == "data_train.cont_rating"] <- "cont_rating"
```

### Análisis de la variable.

En el caso que nos ocupa es el de Apple Store, que establece 4 clasificaciones:

```{r}
unique(Rating$cont_rating)
```

### Primer nivel: 4+
- No contiene material objetable, por lo que pueden ser consumidas por niños de hasta 11 años.

### Segundo nivel: 9+
- Puede contener ocurrencias leves o infrecuentes de dibujos animados, fantasía o violencia realista, y contenido maduro, sugerente o temático de terror, leve o infrecuente, que puede no ser adecuado para niños menores de 9 años.

### Tercer nivel: 12+
- Puede contener dibujos animados frecuentes o intensos, fantasía o violencia realista, temas maduros o sugestivos leves o infrecuentes, mal lenguaje suave o infrecuente, y juegos de azar simulados que pueden no ser adecuados para niños menores de 12 años.

### Último nivel: 17 +
- Puede contener lenguaje ofensivo frecuente e intenso, caricaturas excesivas, fantasía o violencia realista, madurez frecuente e intensa, horror, temas sugestivos, contenido sexual, desnudez, alcohol y drogas, o una combinación de cualquiera de estos factores que son inadecuados para personas menores de 17 años de edad. Esto incluye aplicaciones con acceso web sin restricciones. Ninguna persona menor de 16 años puede comprar una aplicación con una calificación de 17+.

Para conocer mejor nuestra variable, utilizaremos la función ‘Table’ y una gráfica ‘plot’ para ver la distribución de la misma en nuestros datos:


```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(Rating, aes(x=cont_rating)) + geom_bar(fill='lightsteelblue2')+
  labs(x = "Rating de la App" , y ="Frecuencia" , title = "Rating por Edad")+ theme(plot.title = element_text(hjust = 0.5, face="bold", size =12), plot.subtitle =element_text(hjust = 0.5, face ="bold", size=10), axis.text.x = element_text(size = 10, hjust = 1), axis.text.y = element_text(size = 10))
```

Observamos que la mayoría de las aplicaciones en Apple Store tienen una clasificación de 4+, es decir, son aptas para todos los públicos, mientras que las que mayor clasificación tienen 17+, son las minoritarias.

### Procesado de la variable

Para realizar un análisis de regresión, todas las variables deben ser numéricas, por lo que dicha variable requiere una recodificación. La recodificación utilizada en este caso se basa en los 4 niveles de rating, por cada nivel crearemos una nueva variable con dos niveles cada una:

####Categoría_4+.
1, cuando la aplicación está categorizada por 4+.
0, cuando la aplicación no está categorizada como 4+.

####Categoría_9+.
1, cuando la aplicación está categorizada por 9+.
0, cuando la aplicación no está categorizada como 9+.

####Categoría_12+.
1, cuando la aplicación está categorizada por 12+.
0, cuando la aplicación no está categorizada como 12+.

####Categoría_17+.
1, cuando la aplicación está categorizada por 17+.
0, cuando la aplicación no está categorizada como 17+.

```{r}
# Categorizamos la variable en los 4 niveles.
# Cargamos los paquetes dummies
data_train <- cbind(data_train, dummy(data_train$cont_rating))
#Rename
names(data_train)[names(data_train) == "data_train17+"] <- "rating_17+"
names(data_train)[names(data_train) == "data_train12+"] <- "rating_12+"
names(data_train)[names(data_train) == "data_train9+"] <- "rating_9+"
names(data_train)[names(data_train) == "data_train4+"] <- "rating_4+"
```

## Variable Prime_genre

En la plataforma de Apple Store, se dividen las aplicaciones en 23 clasificaciones dependiendo del género de las mismas.

```{r include=FALSE}
genero <- data.frame(data_train$X, data_train$prime_genre)

names(genero)[names(genero) == "data_train.X"] <- "X"
names(genero)[names(genero) == "data_train.prime_genre"] <- "genero"
```

```{r}
unique(genero$genero)
```

### Análisis de la variable.

Para conocer más la variable y cómo análisis exploratorio de la misma, generamos el número de aplicaciones por género, además de un porcentaje sobre el total de aplicaciones.


```{r}
genero_tab<- data.frame(table(genero$genero))
genero_tab = mutate(genero_tab, percent = Freq/ sum(Freq))
names(genero_tab)[names(genero_tab) == "Var1"] <- "genero"
genero_tab
```


```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(genero_tab, aes(x="", y=Freq, fill=genero)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  labs(title = "Genero de la App")+
  theme(plot.title = element_text(hjust = 0.5, face="bold", size =12))
```

Cómo podemos observar en la gráfica siguiente, el género que mayor tasa de aplicaciones es el género “Games” con un 50% de las aplicaciones. El resto de las aplicaciones se dividen entre las 22 categorías de Apple Store. Debido a esta problemática, optaremos por crear cuatro nuevas clasificaciones partiendo de las clasificaciones de la tienda oficial de Apple. Estas nuevas categorías son:

1. Games.
2. Lifestyle.
3. Utilities.
4. Entertainment.

```{r}
#Creamos las 4 categorías.

genero$genero_new <- 0
genero$genero_new [genero$genero == 'Games'] <-"Games"
genero$genero_new [genero$genero == 'Business'       |genero$genero == 'Catalogs'
                 |genero$genero == 'Education'       |genero$genero == 'Finance'
                 |genero$genero == 'Health & Fitness'|genero$genero == 'Lifestyle'
                 |genero$genero == 'Medical'         |genero$genero == 'Sports'
                 |genero$genero == 'Travel']<- "Lifestyle"

genero$genero_new [genero$genero == 'Utilities' |genero$genero == 'Weather'
                 |genero$genero == 'Navigation' |genero$genero == 'Productivity'
                 |genero$genero == 'Reference' ]<- "Utilities"

genero$genero_new [genero$genero == 'Entertainment'|genero$genero == 'Book'
                 |genero$genero == 'Food & Drink'  |genero$genero == 'Music'
                 |genero$genero == 'News'          |genero$genero == 'Photo & Video'
                 |genero$genero == 'Shopping'      |genero$genero =='Social Networking'
                 ]<- "Entertainment"
genero_new <- select(genero,X, genero_new)
unique(genero_new$genero_new)
```

```{r}
# Analizamos la nueva variable
genero_new<- data.frame(table(genero_new$genero_new))
genero_new = mutate(genero_new, percent = Freq/ sum(Freq))
names(genero_new)[names(genero_new) == "Var1"] <- "genero"
genero_new
```

Las nuevas categorías presentan una distribución diferente, donde encontramos que el género “Games” sigue siendo el mayoritario en nuestros datos, seguido del género “Entertainment” y “Lifestyles”. El género con menor número de aplicaciones es “Utilities”.

```{r, warning= FALSE, fig.align='center', fig.show='hold', fig.width=6, fig.height=4, echo=FALSE, message=FALSE}
ggplot(genero_new, aes(x="", y=Freq, fill=genero)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  labs(title = "Genero de la App")+
  theme(plot.title = element_text(hjust = 0.5, face="bold", size =12))
```

### Procesado de la variable.

El procesado de esta variable se llevará a cabo creando 4 nuevas columnas dentro de nuestro datasets origen, para cada nuevo género.

Games_genre:
  1, cuando la aplicación está categorizada como “Juegos”.
  0, cuando la aplicación no está categorizada como “Juegos”.

Entertainment_genre:
  1, cuando la aplicación está categorizada como “Entretenimiento”.
  0, cuando la aplicación no está categorizada como “Entretenimiento”.

Utilities_genre:
  1, cuando la aplicación está categorizada como “Utilidades”.
  0, cuando la aplicación no está categorizada como “Utilidades”.

Lifestyle_genre:
  1, cuando la aplicación está categorizada como “Estilo de vida”.
  0, cuando la aplicación no está categorizada como “Estilo de vida”.


```{r}
# Integramos con Apple_Store y creamos una columna para cada categoría.

genero <- select(genero,X, genero_new)
data_train <- merge (x= data_train, y=genero, by="X")

data_train <- cbind(data_train, dummy(data_train$genero_new))
names(data_train)[names(data_train) == "data_trainGames"] <- "Games_genre"
names(data_train)[names(data_train) == "data_trainLifestyle"] <- "Lifestyle_genre"
names(data_train)[names(data_train) == "data_trainEntertainment"] <- "Entertainment_genre"
names(data_train)[names(data_train) == "data_trainUtilities"] <- "Utilities_genre"
```

```{r}
data_train_new <- data_train %>% select(
  4,6,7,8,12,14,16,17,18,19,20,21,22,24,25,26,27)
```

```{r}
head(data_train_new)
```

---

Nota: por falta de tiempo, no hemos podido completar los siguientes apartados.

# Selección de variables

Para seleccionar qué variables son las más significativas para nuestro modelo, aplicamos uno de los métodos para obtenerlas automáticamente evaluándolas con uno de los parámetros propuestos. En este caso, usamos "R cuadrado ajustado".

```{r}
# Eliminamos la variable original del género y nos quedamos con la transformada
data_train_clean <- data_train %>%
  select(-c(prime_genre))

# Calculamos los "Best subsets"
regfit_full <- leaps::regsubsets(rating_count_tot~., data_train_clean)

reg_sum <- summary(regfit_full)

# Estos son los valores de R cuadrado ajustado
reg_sum$adjr2

plot(regfit_full, scale="adjr2")

coef(regfit_full, 6)
```

# Ajuste, interpretación y diagnosis del modelo de regresión lineal múltiple

## Definición del modelo

## Interpretación de resultados

## Diagnósis del modelo

